package com.fanxing.server.persist.impl;

import java.io.Serializable;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import org.hibernate.EntityMode;
import org.hibernate.Query;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;
import org.hibernate.persister.entity.EntityPersister;
import org.hibernate.proxy.HibernateProxy;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.fanxing.server.cache.Cache;
import com.fanxing.server.io.ConfigurationHolder;
import com.fanxing.server.persist.DataAccessException;
import com.fanxing.server.persist.EntityManager;
import com.fanxing.server.sequence.InstanceIdManager;

public class EntityManagerImpl implements EntityManager {
	
	private Logger log;
	
	private Configuration conf;
	
	private SessionFactory sessionFactory;
	
	private HashMap<String, EntityPersister> entityPersisters;
	
	private HashMap<String, Lock> locks;
	
	private Cache cache;
	
	private InstanceIdManager idManager;
	
	public EntityManagerImpl(Configuration conf, Cache cache, InstanceIdManager idManager) {
		this.conf = conf;
		this.cache = cache;
		this.idManager = idManager;
		log = LoggerFactory.getLogger(EntityManagerImpl.class);
		initHibernate();
		initLocks();
	}
	
	public EntityManagerImpl(Configuration conf, ConfigurationHolder configuration) {
		this.conf = conf;
		log = LoggerFactory.getLogger(EntityManagerImpl.class);
		initHibernate();
		initCache(configuration);
		initLocks();
	}
	
	@SuppressWarnings("rawtypes")
	private void initHibernate() {
		if (conf == null) {
			conf = new Configuration();
			conf.configure();
		}
		sessionFactory = conf.buildSessionFactory();
		entityPersisters = new HashMap<String,EntityPersister>();
		Iterator ite = sessionFactory.getAllClassMetadata().entrySet().iterator(); 
		while (ite.hasNext()) {
			Map.Entry entry = (Map.Entry) ite.next();
			String entityName = (String) entry.getKey();
			EntityPersister entityPersister = (EntityPersister) entry.getValue();
			entityPersisters.put(entityName, entityPersister);
		}
	}
	
	private void initLocks() {
		locks = new HashMap<String,Lock>();
		Iterator<String> ite = entityPersisters.keySet().iterator();
		while (ite.hasNext()) {
			String entityName = ite.next();
			locks.put(entityName, new ReentrantLock());
		}
	}
	
	private Lock getLock(String name) {
		return locks.get(name);
	}
	
	private void initCache(ConfigurationHolder configuration) {
		try {
			@SuppressWarnings("unchecked")
			Class<Cache> clz = (Class<Cache>) Class.forName(configuration.getConfigurationValue("cache_class"));
			cache = clz.getConstructor(ConfigurationHolder.class).newInstance(configuration);
			
			if (cache instanceof InstanceIdManager) {
				idManager = (InstanceIdManager) cache;
			}
		} catch (Exception e) {
			log.error("", e);
		}
	}
	
	private Session getSession() {
		return sessionFactory.getCurrentSession();
	}
	
	private void checkCreateObject(Serializable o) {
		if(o instanceof HibernateProxy) {
			throw new IllegalArgumentException();
		}
	}

	@Override
	public void createSync(Serializable entity) {
		checkCreateObject(entity);
		String entityName = entity.getClass().getName();
		Lock lock = getLock(entityName);
		lock.lock();
		try{
			Session session = getSession();
			Transaction tx = session.beginTransaction();
			try {
				session.save(entity);
				tx.commit();
			} catch (Exception e) {
				tx.rollback();
				throw e;
			}
		} catch(Exception ex) {
			throw new DataAccessException(ex);
		} finally{
			lock.unlock();
		}
	}

	@Override
	public void createSync(Serializable[] entity) {
		for (Serializable en : entity) {
			createSync(en);
		}
	}
	
	private Serializable getEntityIdentifier(String entityName, Object entity, EntityMode entityMode) {
		EntityPersister eper = entityPersisters.get(entityName);
		return eper.getIdentifier(entity, entityMode);
	}

	@Override
	public void deleteSync(Serializable entity) {
		String entityName = entity.getClass().getName();
		Lock lock = getLock(entityName);
		lock.lock();
		try {
			Session session = getSession();
			Transaction tx = session.beginTransaction();
			try {
				session.delete(entity);
				tx.commit();
			} catch (Exception e) {
				tx.rollback();
				throw e;
			}
		} catch (Exception ex) {
			throw new DataAccessException(ex);
		} finally{
			lock.unlock();
		}
	}

	@Override
	public void deleteSync(Serializable[] entity) {
		for (Serializable en : entity) {
			deleteSync(en);
		}
	}

	@Override
	public void updateSync(Serializable entity) {
		String entityName = entity.getClass().getName();
		Lock lock = getLock(entityName);
		lock.lock();
		try {
			Serializable id = getEntityIdentifier(entityName, entity, EntityMode.POJO);
			Session session = getSession();
			Transaction tx = session.beginTransaction();
			try {
				session.update(entity);
				tx.commit();
				cache.hset(entityName, id, entity);
			} catch (Exception e) {
				tx.rollback();
				throw new DataAccessException(e);
			}
		} catch(DataAccessException e) {
			throw e;
		} catch(Exception e) {
			throw new DataAccessException(e);
		} finally{
			lock.unlock();
		}
	}

	@Override
	public void updateSync(Serializable[] entity) {
		for (Serializable en : entity) {
			updateSync(en);
		}
	}

	@SuppressWarnings("unchecked")
	@Override
	public <T extends Serializable> T fetch(Class<T> klass, String hql, Object... values) {
		return (T) fetch(klass.getName(), hql, values);
	}

	@Override
	public Object fetch(String entityName, String hql, Object... values) {
		Lock lock = getLock(entityName);
		lock.lock();
		try {
			Session session = getSession();
			Transaction tx = session.beginTransaction();
			try {
				Query query = getSession().createQuery(hql);
				if (values != null) {
					for (int i = 0; i < values.length; i++) {
						query.setParameter(i, values[i]);
					}
				}
				Object entity = query.uniqueResult();
				session.clear();
				tx.commit();
				if (entity == null) {
					return null;
				}
				return entity;
			} catch (Exception e) {
				tx.rollback();
				throw new DataAccessException(e);
			}
		} catch(DataAccessException e) {
			throw e;
		} catch(Exception e) {
			throw new DataAccessException(e); 
		} finally {
			lock.unlock();
		}
	}

	@SuppressWarnings("unchecked")
	@Override
	public <T extends Serializable> List<T> query(Class<T> klass, String hql, Object... values) {
		return query(klass.getName(), hql, values);
	}

	@SuppressWarnings({ "rawtypes" })
	@Override
	public List query(String entityName, String hql, Object... values) {
		Lock lock = getLock(entityName);
		lock.lock();
		try{
			Session session = getSession();
			Transaction tx = session.beginTransaction();
			try {
				Query query = getSession().createQuery(hql);
				if (values != null) {
					for (int i = 0; i < values.length; i++) {
						query.setParameter(i, values[i]);
					}
				}
				List list = query.list();
				session.clear();
				tx.commit();
				return list;
			} catch (Exception e) {
				tx.rollback();
				throw new DataAccessException(e);
			}
		} catch(DataAccessException e) {
			throw e;
		} catch(Exception e) {
			throw new DataAccessException(e); 
		} finally {
			lock.unlock();
		}
	}

	@SuppressWarnings("unchecked")
	@Override
	public <T extends Serializable> List<T> limitQuery(Class<T> klass, String hql, int start, int count, Object... values) {
		return limitQuery(klass.getName(), hql, start, count, values);
	}

	@SuppressWarnings({ "rawtypes" })
	@Override
	public List limitQuery(String entityName, String hql, int start, int count, Object... values) {
		Lock lock = getLock(entityName);
		lock.lock();
		try {
			Session session = getSession();
			Transaction tx = session.beginTransaction();
			try {
				Query query = getSession().createQuery(hql);
				if (values != null) {
					for (int i = 0; i < values.length; i++) {
						query.setParameter(i, values[i]);
					}
				}
		        query.setFirstResult(start);
		        query.setMaxResults(count);
				List list = query.list();
		        session.clear();
				tx.commit();
				return list;
			} catch (Exception e) {
				tx.rollback();
				throw new DataAccessException(e);
			}
		} catch(DataAccessException e) {
			throw e;
		} catch(Exception e) {
			throw new DataAccessException(e); 
		} finally {
			lock.unlock();
		}
	}

	@Override
	public long count(String hql, Object... values) {
		Session session = getSession();
		Transaction tx = session.beginTransaction();
		try {
			Query query = getSession().createQuery(hql);
			if (values != null) {
				for (int i = 0; i < values.length; i++) {
					query.setParameter(i, values[i]);
				}
			}
			Number temp = (Number) query.uniqueResult();
			long ret = 0L;
			if (temp != null) {
				ret = temp.longValue();
			}
			session.clear();
			tx.commit();
			return ret;
		} catch(Exception e) {
			tx.rollback();
			throw new DataAccessException(e);
		}
	}

	@SuppressWarnings("rawtypes")
	@Override
	public List nativeQuery(String hql, Object... values) {
		Session session = getSession();
		Transaction tx = session.beginTransaction();
		try {
			Query query = session.createQuery(hql);
			if (values != null) {
				for (int i = 0; i < values.length; i++) {
					query.setParameter(i, values[i]);
				}
			}
			List ret = query.list();
			tx.commit();
			return ret;
		} catch (Exception e) {
			tx.rollback();
			throw new DataAccessException(e);
		}
	}

	@Override
	public void shutdown() throws Exception {
		sessionFactory.close();
	}

	@Override
	public Configuration getConfiguration() {
		return conf;
	}

	@Override
	public void clearLocal(@SuppressWarnings("rawtypes") Class klass) {
		cache.del(klass.getName());
	}

	@Override
	public InstanceIdManager getInstanceIdManager() {
		return idManager;
	}

	@Override
	public Cache getCache() {
		return cache;
	}

}
